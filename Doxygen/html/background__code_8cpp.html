<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kompresja oraz tekstu na podstawie algorytmów RLE i ByteRun: Dokumentacja pliku RLE-and-BYTERUN/background_code.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kompresja oraz tekstu na podstawie algorytmów RLE i ByteRun
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Autorzy: Kostecki Michał, Kłusek Wojciech Grupa 2|D13A</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Wygenerowano przez Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Szukaj');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Szukaj');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('background__code_8cpp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Funkcje</a>  </div>
  <div class="headertitle">
<div class="title">Dokumentacja pliku background_code.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="background__code_8h_source.html">background_code.h</a>&quot;</code><br />
</div>
<p><a href="background__code_8cpp_source.html">Idź do kodu źródłowego tego pliku.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funkcje</h2></td></tr>
<tr class="memitem:afcbd6e1c2b4014746d5939c3ee3958a5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="background__code_8cpp.html#afcbd6e1c2b4014746d5939c3ee3958a5">intToStr</a> (int n)</td></tr>
<tr class="memdesc:afcbd6e1c2b4014746d5939c3ee3958a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja konwertuje wartość typu int podaną w argumencie na napis. Używana na etapie kompresji liczby powtórzeń danego znaku i zapisania jej jako tekst skompresowany.  <a href="#afcbd6e1c2b4014746d5939c3ee3958a5">Więcej...</a><br /></td></tr>
<tr class="separator:afcbd6e1c2b4014746d5939c3ee3958a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac90fece704133846f13413f49f13a6a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="background__code_8cpp.html#aac90fece704133846f13413f49f13a6a">compressRLE</a> (string user_input)</td></tr>
<tr class="memdesc:aac90fece704133846f13413f49f13a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kompresja algorytmem RLE: Najpierw z wejściowego ciągu znaków usuwamy znak oddzielenia "`" poszczególnych powtarzających się podciągów liter. Następnie w pętli odczytujemy tak postały ciąg znak po znaku. Jeśli obok siebie występują dwa takie same znaki to zwiększany jest licznik powtórzeń. Natomiast jeśli znaki leżące obok siebie przestały się powtarzać program dodaje do ciągu wyjściowego znak który się powtarzał oraz liczbę jego powtórzeń zmniejszoną o jeden oraz przekonwertowaną na tekst funkcją IntToStr(), wszystko to pomiędzy znakami oddzielającymi "`". W przypadku gdy w ciągu wejściowym był tylko jeden znak to jest on dodawany do ciągu wyjściowego. Na koniec licznik powtórzeń jest przywracany do wartości 1.  <a href="#aac90fece704133846f13413f49f13a6a">Więcej...</a><br /></td></tr>
<tr class="separator:aac90fece704133846f13413f49f13a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610f48f865f70ca1b7d47b536fe999ec"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="background__code_8cpp.html#a610f48f865f70ca1b7d47b536fe999ec">decompressRLE</a> (string compressed)</td></tr>
<tr class="memdesc:a610f48f865f70ca1b7d47b536fe999ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dekompresja RLE: <br />
 Funkcja przeszukuje skompresowany ciąg wejściowy, w pętli znak po znaku, szukając w nim znaku oddzielenia "`", po którym następuje znak który sie powtarza oraz pierwsza cyfra powtórzeń np 'c3. Po znalezieniu takiego znaku funkcja ustawia zmienną bool na true i iteruje dalej szukając dalszych cyfr powtórzeń oraz drugiego znaku "`" oznaczającego koniec powtórzenia. Gdy tak sie stanie pętla while jest przerywana i otrzymujemy liczbę znaków jakie zajmuje powtórzenie np 'c321' w iteratorze search_end. <br />
 Następnie przechodzimy od drugiego znaku powtórzenia do jego końca zamieniając zapisując kolejne cyfry powtórzenia i zamieniając je na wartość int funkcją atoi(). Gdy to sie stanie funkcja wpisuje do ciągu wyjściowego dany znak tyle razy ile się powtórzył ,a iterator i przeszukujący cały ciąg wejściowy przesuwa się do przodu ciągu wejściowego aby zbadać następne skompresowane znaki<br />
 Natomiast jeśli zmienna boolowska ma wartość false to nie ma powtórzenia i znak jest wpisywany do ciągu wyjściowego, jeśli do zbadania był tylko jeden znak to jest on wpisywany do ciągu wejściowego. Główna pętla for kończy się wraz z końcem ciągu wejściowego*.  <a href="#a610f48f865f70ca1b7d47b536fe999ec">Więcej...</a><br /></td></tr>
<tr class="separator:a610f48f865f70ca1b7d47b536fe999ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff585405ec35362b6ab8db76f49e6a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="background__code_8cpp.html#a70ff585405ec35362b6ab8db76f49e6a">compressBYTERUN</a> (string user_input)</td></tr>
<tr class="memdesc:a70ff585405ec35362b6ab8db76f49e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kompresja algorytmem Byterun: <br />
 Funkcja przegląda cały ciąg wejściowy szukając czy znak następny jest taki sam jak ten badany i zwiększając licznik powtórzeń znaku. <br />
 Jeśli znaki dwa znaki się nie powtarzają to w pętli while sprawdzane jest czy po znaku badanym nie występują dwa takie same znaki. Jeśli nie to zwiększany jest licznik niepowtarzających się znaków, aź do momentu gdy warunek pętli przestanie być prawdziwy. Po wyjściu z pętli liczba niepowtarzających się znaków jest konwertowana na tekst, oddzielana przecinkiem i wprowadzana w ciąg wyjściowy, razem z niepowtarzającymi się znakami oddzielonymi przecinkiem. Przesuwany jest też iterator głównej pętli za skompresowane już znaki<br />
 Natomiast jeśli znaki się powtarzają oznacza się liczbę znaków powtarzających się jako -a znaków gdzie 'a' to liczba powtórzeń -1, oraz wprowadza się minus, liczbę powtórzeń, i znak powtórzony do ciągu wyjściowego odpowiednio oddzielając je przecinkami. <br />
 Na koniec zmienne liczące są resetowane*.  <a href="#a70ff585405ec35362b6ab8db76f49e6a">Więcej...</a><br /></td></tr>
<tr class="separator:a70ff585405ec35362b6ab8db76f49e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762c97b0e04c17e1bb7fe56a826d43f0"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="background__code_8cpp.html#a762c97b0e04c17e1bb7fe56a826d43f0">decompressBYTERUN</a> (string compressed)</td></tr>
<tr class="memdesc:a762c97b0e04c17e1bb7fe56a826d43f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dekompresja Byterun: <br />
 Liczba dodatnia oznacza liczbę niepowtarzających się znaków a liczba ujemna liczbę znaków powtarzających się -1. Wykaz użytych kodów ASCII: 44:przecinek, 45:minus, &lt;48,57&gt; cyfra, <br />
 Funkcja przeszukuje ciąg wejściowy. Jeśli znaleziono minus a po nim cyfrę to określany ile jeszcze znaków zajmuje liczba powtórzeń. Następnie przechodzimy przez cyfry powtórzenia umieszczając je w pomocniczym ciąg i dodając do każdej z nich 1 (-3=4 powtórzenia) i konwertując na int i wpisując powtarzający się znak do ciągu wyjściowego tyle razy ile się powtórzył. <br />
 Jeśli natomiast w ciągu wejściowym natrafimy na cyfrę niepoprzedzoną minusem zliczamy ile jest w ciągu wejściowym cyfr określających liczbę niepowtarzających się znaków. Jeśli po cyfrze nie ma przecinka znaczy to że jest więcej cyfr składających się na liczbę powtórzeń i trzeba zwiększyć iterator j określający ich liczbę. Następnie jeśli (j==i) to od razu znana jest liczba niepowtarzających sie znaków, można ją pobrać do ciągu pomocniczego i przekonwertować na int Jeśli (j!=i) wtedy od początku cyfr określających liczbę niepowtarzających się znaków do ich końca są one zapisywane do pomocniczego ciągu tekstowego i konwertowane na liczbę. Następnie wypisujemy wszystkie niepowtarzające się znaki pomijając przecinki umieszczone po każdej literze.  <a href="#a762c97b0e04c17e1bb7fe56a826d43f0">Więcej...</a><br /></td></tr>
<tr class="separator:a762c97b0e04c17e1bb7fe56a826d43f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Dokumentacja funkcji</h2>
<a id="a70ff585405ec35362b6ab8db76f49e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ff585405ec35362b6ab8db76f49e6a">&#9670;&nbsp;</a></span>compressBYTERUN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string compressBYTERUN </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>user_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kompresja algorytmem Byterun: <br />
 Funkcja przegląda cały ciąg wejściowy szukając czy znak następny jest taki sam jak ten badany i zwiększając licznik powtórzeń znaku. <br />
 Jeśli znaki dwa znaki się nie powtarzają to w pętli while sprawdzane jest czy po znaku badanym nie występują dwa takie same znaki. Jeśli nie to zwiększany jest licznik niepowtarzających się znaków, aź do momentu gdy warunek pętli przestanie być prawdziwy. Po wyjściu z pętli liczba niepowtarzających się znaków jest konwertowana na tekst, oddzielana przecinkiem i wprowadzana w ciąg wyjściowy, razem z niepowtarzającymi się znakami oddzielonymi przecinkiem. Przesuwany jest też iterator głównej pętli za skompresowane już znaki<br />
 Natomiast jeśli znaki się powtarzają oznacza się liczbę znaków powtarzających się jako -a znaków gdzie 'a' to liczba powtórzeń -1, oraz wprowadza się minus, liczbę powtórzeń, i znak powtórzony do ciągu wyjściowego odpowiednio oddzielając je przecinkami. <br />
 Na koniec zmienne liczące są resetowane*. </p>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_input</td><td>Ciąg wejściowy nieskompresowany. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Zwraca</dt><dd>Ciąg wyjściowy skompresowany. </dd></dl>

<p class="definition">Definicja w linii <a class="el" href="background__code_8cpp_source.html#l00149">149</a> pliku <a class="el" href="background__code_8cpp_source.html">background_code.cpp</a>.</p>

</div>
</div>
<a id="aac90fece704133846f13413f49f13a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac90fece704133846f13413f49f13a6a">&#9670;&nbsp;</a></span>compressRLE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string compressRLE </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>user_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kompresja algorytmem RLE: Najpierw z wejściowego ciągu znaków usuwamy znak oddzielenia "`" poszczególnych powtarzających się podciągów liter. Następnie w pętli odczytujemy tak postały ciąg znak po znaku. Jeśli obok siebie występują dwa takie same znaki to zwiększany jest licznik powtórzeń. Natomiast jeśli znaki leżące obok siebie przestały się powtarzać program dodaje do ciągu wyjściowego znak który się powtarzał oraz liczbę jego powtórzeń zmniejszoną o jeden oraz przekonwertowaną na tekst funkcją IntToStr(), wszystko to pomiędzy znakami oddzielającymi "`". W przypadku gdy w ciągu wejściowym był tylko jeden znak to jest on dodawany do ciągu wyjściowego. Na koniec licznik powtórzeń jest przywracany do wartości 1. </p>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_input</td><td>Ciąg wejściowy nieskompresowany. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Zwraca</dt><dd>Ciąg wyjściowy skompresowany. </dd></dl>

<p class="definition">Definicja w linii <a class="el" href="background__code_8cpp_source.html#l00041">41</a> pliku <a class="el" href="background__code_8cpp_source.html">background_code.cpp</a>.</p>

</div>
</div>
<a id="a762c97b0e04c17e1bb7fe56a826d43f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c97b0e04c17e1bb7fe56a826d43f0">&#9670;&nbsp;</a></span>decompressBYTERUN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string decompressBYTERUN </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>compressed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dekompresja Byterun: <br />
 Liczba dodatnia oznacza liczbę niepowtarzających się znaków a liczba ujemna liczbę znaków powtarzających się -1. Wykaz użytych kodów ASCII: 44:przecinek, 45:minus, &lt;48,57&gt; cyfra, <br />
 Funkcja przeszukuje ciąg wejściowy. Jeśli znaleziono minus a po nim cyfrę to określany ile jeszcze znaków zajmuje liczba powtórzeń. Następnie przechodzimy przez cyfry powtórzenia umieszczając je w pomocniczym ciąg i dodając do każdej z nich 1 (-3=4 powtórzenia) i konwertując na int i wpisując powtarzający się znak do ciągu wyjściowego tyle razy ile się powtórzył. <br />
 Jeśli natomiast w ciągu wejściowym natrafimy na cyfrę niepoprzedzoną minusem zliczamy ile jest w ciągu wejściowym cyfr określających liczbę niepowtarzających się znaków. Jeśli po cyfrze nie ma przecinka znaczy to że jest więcej cyfr składających się na liczbę powtórzeń i trzeba zwiększyć iterator j określający ich liczbę. Następnie jeśli (j==i) to od razu znana jest liczba niepowtarzających sie znaków, można ją pobrać do ciągu pomocniczego i przekonwertować na int Jeśli (j!=i) wtedy od początku cyfr określających liczbę niepowtarzających się znaków do ich końca są one zapisywane do pomocniczego ciągu tekstowego i konwertowane na liczbę. Następnie wypisujemy wszystkie niepowtarzające się znaki pomijając przecinki umieszczone po każdej literze. </p>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramname">compressed</td><td>Ciąg wejściowy skompresowany </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Zwraca</dt><dd>Ciąg wyjściowy nieskompresowany </dd></dl>

<p class="definition">Definicja w linii <a class="el" href="background__code_8cpp_source.html#l00205">205</a> pliku <a class="el" href="background__code_8cpp_source.html">background_code.cpp</a>.</p>

</div>
</div>
<a id="a610f48f865f70ca1b7d47b536fe999ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610f48f865f70ca1b7d47b536fe999ec">&#9670;&nbsp;</a></span>decompressRLE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string decompressRLE </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>compressed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dekompresja RLE: <br />
 Funkcja przeszukuje skompresowany ciąg wejściowy, w pętli znak po znaku, szukając w nim znaku oddzielenia "`", po którym następuje znak który sie powtarza oraz pierwsza cyfra powtórzeń np 'c3. Po znalezieniu takiego znaku funkcja ustawia zmienną bool na true i iteruje dalej szukając dalszych cyfr powtórzeń oraz drugiego znaku "`" oznaczającego koniec powtórzenia. Gdy tak sie stanie pętla while jest przerywana i otrzymujemy liczbę znaków jakie zajmuje powtórzenie np 'c321' w iteratorze search_end. <br />
 Następnie przechodzimy od drugiego znaku powtórzenia do jego końca zamieniając zapisując kolejne cyfry powtórzenia i zamieniając je na wartość int funkcją atoi(). Gdy to sie stanie funkcja wpisuje do ciągu wyjściowego dany znak tyle razy ile się powtórzył ,a iterator i przeszukujący cały ciąg wejściowy przesuwa się do przodu ciągu wejściowego aby zbadać następne skompresowane znaki<br />
 Natomiast jeśli zmienna boolowska ma wartość false to nie ma powtórzenia i znak jest wpisywany do ciągu wyjściowego, jeśli do zbadania był tylko jeden znak to jest on wpisywany do ciągu wejściowego. Główna pętla for kończy się wraz z końcem ciągu wejściowego*. </p>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramname">compressed</td><td>Ciąg wejściowy skompresowany </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Zwraca</dt><dd>Ciąg wyjściowy nieskompresowany </dd></dl>

<p class="definition">Definicja w linii <a class="el" href="background__code_8cpp_source.html#l00091">91</a> pliku <a class="el" href="background__code_8cpp_source.html">background_code.cpp</a>.</p>

</div>
</div>
<a id="afcbd6e1c2b4014746d5939c3ee3958a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbd6e1c2b4014746d5939c3ee3958a5">&#9670;&nbsp;</a></span>intToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string intToStr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja konwertuje wartość typu int podaną w argumencie na napis. Używana na etapie kompresji liczby powtórzeń danego znaku i zapisania jej jako tekst skompresowany. </p>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Wyliczona liczba powtórzeń danego znaku jako typ int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Zwraca</dt><dd>Liczba powtórzeń znaku typu string w postaci skompresowanej </dd></dl>

<p class="definition">Definicja w linii <a class="el" href="background__code_8cpp_source.html#l00010">10</a> pliku <a class="el" href="background__code_8cpp_source.html">background_code.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_1b95eeb57d12ea8d038c735fb3c3f438.html">RLE-and-BYTERUN</a></li><li class="navelem"><a class="el" href="background__code_8cpp.html">background_code.cpp</a></li>
    <li class="footer">Wygenerowano przez
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
